# CwActsAsOrdered
module CW
module ActsAs
module Ordered


# Model Acts As Ordered Inclusion
#
# When included in a model (include CW::ActsAs::Ordered::Model), the methods contained within provide for basic manipulation of order of records. This does not change the ID, but rather an ordering integer. While a user or developer may sort these records however one chooses, this plug-in is designed to allow the developer to quickly allow a universal ordering.
#
# This is useful for lists of records that require a manual ordering. For example, if you have a list of candy preferences, you can put chocolate at the top using up, down, top, and bottom controls that map to methods provided by this module.
#
# Core to understanding how an advanced feature of this include works is understanding an exclusivity group. Now, most of you won't deal with them and, therefore, won't care what they are or how to use them. But if you need them, this feature is a necessity.
#
# An exclusivity group allows you to have multiple orderings within orderings. Think of it as adding a scope to the ordering information. With exclusivity groups, you can "group" your records and sort each "group" independently of other groups.
#
# Taking our candy list example above as an extension, if you wanted to have all users create his or her own orderings of candy, then you use the exclusivity group based on the user's ID. Users can sort their own lists, but all sorting is done within the same table. Now that I think about it, this is a pretty lousy way to do this. But I needed something really quick. Crud.
#
# Anyway, exclusivity groups are optional. If you don't use them, all objects are assumed to have no exclusivity group and therefore are part of a universal exclusivity group.
#
# Examples:
#
# Suppose you have a model of records you want to order. I'm assuming they're unordered before we start (otherwise, why do you need this?)
#
# class Candy < ActiveRecord::Base
# end
#
# For now, assume your schema is pretty bare:
#	
# class CreateCandies < ActiveRecord::Migration
#   def self.up
#     create_table :candies do |t|
#       t.column :name, :string
#     end
#		end
#		def self.down
#			drop_table :candies
#		end
#	end
#
#	So, there you have it. A set of candies with names. To order them, you'll add 1 more migration and modify the Candy class slightly:
#
# class Candy < ActiveRecord::Base
#		include CW::ActsAs::Ordered::Model # You're including the model code here
# end
#
# For now, assume your schema is pretty bare:
#	
# class OrderingCandies < ActiveRecord::Migration
#         include CW::ActsAs::Ordered::Migration #include migration code
#   def self.up
#			add_order( "MyOrderedModel" )
#		end
#		def self.down
#			# Rolling back WILL lose information about ordering your candies
#			remove_order( "MyOrderedModel" )
#		end
#	end
#
# Replace the string "MyOrderedModel" with the name of you model to which you're adding order. You're done. This process, of course, assumes that your tables are empty and there is nothing to order, yet. If your table is not empty and you're adding an order to an existing data set, all records will be updated with unique ranks after adding these columns.
#
# Note, the order column (including exclusivity columns, discussed later) is indexed and uniqueness is enforced. Nil/NULL values are not considered to be unique in most databases.
#
# That will populate all your candies with an order based on the IDs of each candy. I assume, of course, that your candies table has an id field (primary key).
#
# Exclusivity Groups:
#
# To use exclusivity groups, you must first create a field for them in your database. You can create the order and exclusivity fields by calling:
# add_order_with_exclusivity( klass_name, order_column_name = :acts_as_ordered_order, exclusivity_column_name = :acts_as_ordered_exclusivity_id, exclusivity_column_type = :integer )
#
# from within your Migration. Note well that you can change the type of the exclusivity column. For efficiently, integers are best, but if you need something more dynamic, you may change your exclusivity group type to a non-integer.
#
#	Overriding the default column names:
#		You have the option of overriding the column names generated by default. By default, these names are:
#	*	acts_as_ordered_order: The rank within the exclusivity group (if present)
#	* acts_as_ordered_exclusivity_id: The way we group ranks. You can have multiple groupings of ranks. Each group has its own ordering line.
#
# The default column names can be overridden in the Migration by passing them as arguments to the functions. However, you must also tell your Model what their new names are. You do this by defining a class method after you include this module. Suppose you renamed your ordering column to: 'rank' and your exclusivity column to 'user_id', when you create your model, create methods such as below:
#
#	class Candy < ActiveRecord::Base
#		include CW::ActsAs::Ordered::Model
#		def acts_as_ordered_order_attribute_name; :rank; end
#		def acts_as_ordered_order_attribute_name; :user_id; end
#	end
#
# Your migration may look like:
#
# class OrderUserCandies < ActiveRecord::Migration
#         include CW::ActsAs::Ordered::Migration
#   def self.up
# 		add_order_with_exclusivity 'Candy'
#   end
# 
#   def self.down
#     remove_order_with_exclusivity 'Candy'
#   end
# end
#
# Safety:
#		You must never, ever modify the order or exclusivity group without the use of the functions provided. An optimally functioning system relies on this information to function correctly.
#
# Numbering:
#
# The numbering here is inverted. Lower numbers are ranked higher. Like: #1 is the best, #2 is second best, and #1,000,000 is really bad.
module Model
	def self.included(base)
		base.extend(ClassMethods)
		# This is required for Active Record models. New records are immediately given the highest ID You can override this method to make it an arbitrary ID
		base.before_create :acts_as_ordered_before_create
		# Ensures order is preserved for removed entries
		base.after_destroy :acts_as_ordered_prepare_for_destruction
	end

# Swap Order
#
# Simply swaps the order of two models in an exclusivity group. This is done by actually manipulating the IDs within a transaction. The IDs MUST be swapped within a transaction to avoid an inconsistent state AND because there is a numeric constraint on these numbers to be unique. This uniqueness is not enforced.
#
# Arguments:
#		other: (ActiveRecord::Base) to swap positions with
#
#	Returns:
#		(boolean) false if you're trying to swap the item with itself
	def swap_order_with( other )
		self.class.require_acts_as_ordered_have_same_exclusivity_group( self, other )
		return false if self.id.eql?(other.id)

		self.class.transaction do
			old_self = read_attribute( self.class.acts_as_ordered_order_attribute_name )
			old_other = other.send( self.class.acts_as_ordered_order_attribute_name )
			# to preserve uniquness, we need to set the rank to nil first, then to the actual value
			# We're in a transaction, so we should be OK
			# Swap will go like this:
			# old_other = other
			# other = nil
			# self = old_older
			#
			other.send( self.class.acts_as_ordered_order_attribute_name.to_s + '=', nil )
			other.save!
			self.send( self.class.acts_as_ordered_order_attribute_name.to_s + '=', old_other )
			other.send( self.class.acts_as_ordered_order_attribute_name.to_s + '=', old_self )
			self.save!
			other.save!
		end
		true
	end

# Move To
#
# Moves calling model from one location in the ordering to another. If you are jumping many records, all records in between the re-order will need to be touched. This is pretty crappy, but we have to maintain a strict order for all the math to continue working in this module. This is likely the most used method here. This WILL update the database and save this record immediately. Note well, this method will also update other records in the database. If you have copies of them in memory (because you looked them up) you'll need to re-query them again as the database has been updated.
#
# Arguments:
#		location: (Integer|Symbol) of the location you want to move to, allowing this module to fill in the gap left by the move. You can also specify :first and :last to make this item the first or last in the list, respectively. This location is 0-based index. When the order is done being re-arranged, the caller will be AT the location specified. 0..(count - 1). Counts are based on exclusivity groups. If you don't use them, count represents all items
	def move_order_to( location )
		if location.is_a?(Symbol)
			case location
				when :first
					location = 0
				when :last
					location = self.acts_as_ordered_count_in_my_exclusivity - 1
					location = 0 if location < 0
				end
		end

		# we need to update everything in between the start and stop locations
		raise ArgumentError.new( "Argument 'location' is invalid. Got: #{location}" ) if location < 0 # only accept positive positions
		raise ArgumentError.new( "Argument 'location' is invalid. Got: #{location}" ) if location >= self.acts_as_ordered_count_in_my_exclusivity and self.acts_as_ordered_count_in_my_exclusivity > 1 # only accept positions in range, unless empty

		# easy access to our current location
		current_location = read_attribute( self.class.acts_as_ordered_order_attribute_name )

		# Just return true if we're already at the requested location
		# destroyed records need to be moved, even if we're the same location because we're not actually moving
		return true if location.eql?( current_location ) and !new_record? and !destroyed?

# Difference in movement. If < 0, we're moving up, if > 0, we're moving down
#
# < 0 means we're subtracting values from our neighbors: current_location < location
# > 0 means we're adding values to our neighbors: current_location > location
		diff = current_location - location

		# Now, we used to do this by importing all the records and manually updating them. That was pretty stupid. Now, we're going to use database math!
		self.class.transaction do
			# Update our position. This must be done so our class has the correct data in the DB.
			if !destroyed?
				write_attribute( self.class.acts_as_ordered_order_attribute_name, nil )
				self.save! unless new_record?
			end

			# Updates all rows in between the move
			cns = self.class.acts_as_ordered_order_attribute_name

			queries = []
			if diff <= 0
				# current_location < location : op -
				location += 1 if destroyed? # We cheat by not changing the last ID, but when deleting, we're not doing this
				(current_location + 1).upto(location).each do |i|
					q = ["UPDATE #{self.class.table_name} SET #{cns} = #{i - 1} WHERE #{cns} = #{i}"]
					if self.class.acts_as_ordered_has_exclusivity_id?
						q[0] += " AND #{self.class.acts_as_ordered_exclusivity_attribute_name} = ?"
						q << read_attribute( self.class.acts_as_ordered_exclusivity_attribute_name )
					end
					raise 'Unable to re-order records' unless self.class.connection.execute( self.class.send( :sanitize_sql_array, q ) )
				end
			else
				# current_location > location : op +
				(current_location - 1).downto(location).each do |i|
					q = ["UPDATE #{self.class.table_name} SET #{cns} = #{i + 1} WHERE #{cns} = #{i}"]
					if self.class.acts_as_ordered_has_exclusivity_id?
						q[0] += " AND #{self.class.acts_as_ordered_exclusivity_attribute_name} = ?"
						q << read_attribute( self.class.acts_as_ordered_exclusivity_attribute_name )
					end
					raise 'Unable to re-order records' unless self.class.connection.execute( self.class.send( :sanitize_sql_array, q ) )
				end
			end


# We cannot simply use update all. The database isn't smart enough to know that we're ordering a set with unique constraints and it should wait to check at the commit... What we CAN do is create a query, albeit a potentially LONG one to manually order the records.
			if !destroyed?
				write_attribute( self.class.acts_as_ordered_order_attribute_name, location )
				self.save! unless new_record?
			end
		end

#raise self.inspect if self.rank.eql?(10)
		
		return true
	end

# Move up
#
# Moves the order of the caller up by the indicated amount. This actually moves the numerical order DOWN. This is because lower numbers are considered at the "top" while new entries are automatically placed "at the bottom."
#
# Arguments:
#		count: (Integer,optional,default=1) How many to move up
	def move_order_up( count = 1 )
		self.move_order_to( self.send( self.class.acts_as_ordered_order_attribute_name ) - count )
	end



# Move down
#
# Moves the order of the caller down by the indicated amount. This actually moves the numerical order UP. See "Move up" for more information
#
# Arguments:
#		count: (Integer,optional,default=1) How many to move down
	def move_order_down( count = 1 )
		self.move_order_to( self.send( self.class.acts_as_ordered_order_attribute_name ) + count )
	end

# Before create
#
# Assigns the caller as the next available order number (the last number). And ensures that there are no problems in inserting a record out of order or for a different exclusion group
#
	def acts_as_ordered_before_create
		# we're still in the transaction: count the current # of objects to be ordered, that will include us (we're already saved) and use that as the order #
		return true unless self.class.column_names.include?( self.class.acts_as_ordered_order_attribute_name.to_s )
		order = self.send( self.class.acts_as_ordered_order_attribute_name )
		unless order.nil?
			# No order specified, add to end
			# set our current position to the end
			self[self.class.acts_as_ordered_order_attribute_name] = acts_as_ordered_count_in_my_exclusivity
			# try to move
			move_order_to( order )
		else
			# no order assigned, assign the greatest order
			self[self.class.acts_as_ordered_order_attribute_name] = acts_as_ordered_count_in_my_exclusivity
			true
		end
	end

# Count in my exclusivity
#
# Counts all items grouped into the same exclusivity group as the caller
#
#	Returns:
#		(Integer) indicating the number of items in the same exclusivity group as the caller. This is also used as the next order ID (Last)
	def acts_as_ordered_count_in_my_exclusivity
		self.class.count( :conditions => acts_as_ordered_exclusivity_conditions.done )
	end

# First?
#
#	Tests if caller is the first (lowest order number) in the ordered series. Useful for determining to place a "to top" control button.
#
# Returns:
#		(boolean) of true if caller is the first in the exclusivity group, false if otherwise.
	def acts_as_ordered_is_first?
		if self.class.count( :conditions => acts_as_ordered_exclusivity_conditions.and( ["#{self.class.table_name}.#{self.class.acts_as_ordered_order_attribute_name} < ?",self.send( self.class.acts_as_ordered_order_attribute_name )] ).done ).eql?(0)
			true # is first
		else
			false # is not first
		end
	end

# Last?
#
#	Tests if caller is the last (highest order number) in the ordered series. Useful for determining to place a "to top" control button.
#
# Returns:
#		(boolean) of true if caller is the last in the exclusivity group, false if otherwise.
	def acts_as_ordered_is_last?
		if self.class.count( :conditions => acts_as_ordered_exclusivity_conditions.and(["#{self.class.table_name}.#{self.class.acts_as_ordered_order_attribute_name} > ?",self.send( self.class.acts_as_ordered_order_attribute_name )]  ).done ).eql?(0)
			true # is first
		else
			false # is not first
		end
	end

	def acts_as_ordered_exclusivity_conditions
		if self.class.acts_as_ordered_has_exclusivity_id?
			self.class.acts_as_ordered_exclusivity_conditions( self.send( self.class.acts_as_ordered_exclusivity_attribute_name ) )
		else
			CW::Condition.new
		end
	end

# Prepare for destruction
#
# We're about the be destroyed. To prevent creating a "hole" when we're deleted, we need to be moved to the end of the listing and THEN destroyed
#
# Moves this entry to be the last order
	def acts_as_ordered_prepare_for_destruction
		return true unless self.class.column_names.include?( self.class.acts_as_ordered_order_attribute_name.to_s )
		move_order_to :last if !self.acts_as_ordered_count_in_my_exclusivity.eql?( read_attribute( self.class.acts_as_ordered_order_attribute_name ) )
	end


	module ClassMethods
# Order attribute name
#
#	You must place your overriding function AFTER the include CW::ActsAs::Ordered::Model call.
#
# This is the column in the database assigned to storing the ordering value. You MUST have one. If you don't like 'acts_as_ordered_order' as the column name, just override this method in your Model:
# class User < ActiveRecord::Base; include CW::ActsAs::Ordered::Model; def acts_as_ordered_order_attribute_name; :my_name; end; end

		def acts_as_ordered_order_attribute_name
			:acts_as_ordered_order
		end

# Exclusivity Attribute Name
#
#	You must place your overriding function AFTER the include CW::ActsAs::Ordered::Model call.
#
# This is the column in the database assigned to storing the exclusivity id value. You MUST have one IF you elected for an exclusivity column. See the discussion about exclusivity in the class overview. If you don't like 'acts_as_ordered_exclusivity_id' as the column name in your database, just override this method in your Model:
# class User < ActiveRecord::Base; include CW::ActsAs::Ordered::Model; def acts_as_ordered_exclusivity_id; :exclude_by_id; end; end
		def acts_as_ordered_exclusivity_attribute_name
			:acts_as_ordered_exclusivity_id
		end

# Has Exclusivity?
#
# Internal test to see if this model should be governed by an exclusivity ID
#
#	Returns:
#
#		(boolean): true if this class has an exclusivity column and the ordering rules and enforcement are in place, false if all items are in the same exclusivity group (no rankings overlap)
		def acts_as_ordered_has_exclusivity_id?
			self.column_names.include?( self.acts_as_ordered_exclusivity_attribute_name.to_s )
		end

# Repair holes
#
#	Iterates over the entire collection and fills in all the holes. Very useful if you're abusing the structures and have managed to delete models without using the callbacks (such as with delete instead of using destroy: SHAME!)
#
# Also used in existing databases to which you are adding order
		def acts_as_ordered_repair_holes
			acts_as_ordered_each_exclusivity_group do |g|
				self.transaction do
					g.each_with_index do |m,i|
						m.send( self.acts_as_ordered_order_attribute_name.to_s + '=', i )
						m.save!
					end
				end
			end
		end

# Check Integrity
#
#	Verifies that the internal ordering is consistent and as expected
#
# Returns:
#
#		(boolean) true if data is consistent, false if not
		def acts_as_ordered_is_order_consistent?
			acts_as_ordered_each_exclusivity_group do |g|
				0.upto(g.size - 1).each do |i|
					return false unless g[i].send( self.acts_as_ordered_order_attribute_name ).eql?( i )
				end
			end
			true
		end

# Each Exclusivity Group
#
# Iterates over each exclusivity group and provides you with ALL the items within that group. This is NOT an efficient funciton and is designed only for use in dire situations, such as when you need to repair all groups. All results are ordered properly by the current state of the data store.
#
# If there is only 1 group (or no exclusivity groups), then it's the same as find_in_order and returns everything, but in order
#
# Yields:
#		(Array<Model>) an array of models within the exclusivity group
		def acts_as_ordered_each_exclusivity_group
			exclusivity_ids = acts_as_ordered_exclusivity_ids
			if exclusivity_ids
				exclusivity_ids.each do |exclusivity_id|
					yield self.find_in_order_for_exclusivity( exclusivity_id )
				end
			else
				yield self.find_in_order
			end
		end

# Exclusivity IDs
#
# Another internal function. Pulls out all of the Exclusivity ID values. Again, this returns all the values and is probably NOT a good function to use in production
#
#	Returns:
#
#		(Array<EXCLUSIVITY_TYPE>) An array of all distinct exclusivity ids. The type depends on what you decided in your migration. These are integers by default.
		def acts_as_ordered_exclusivity_ids
			self.find(:all, :select => "DISTINCT( #{self.acts_as_ordered_exclusivity_attribute_name} )" ).collect{|m| m.send( m.class.acts_as_ordered_exclusivity_attribute_name ) } if acts_as_ordered_has_exclusivity_id?
		end

# Require Same Exclusivity Group
#
# You cannot swap the order of two objects in different exclusivity groups. It doesn't make sense. The exclusivity groups separate different orderings on the same Active Record model's table. The order of the arguments does not matter.
#
#	Arguments:
#		x: (ActiveRecord)
#		y: (ActiveRecord)
#
#	Raises:
#		ArgumentError if x and y are in different exclusivity groups
		def require_acts_as_ordered_have_same_exclusivity_group( x, y )
			# skip the check if there is no exclusivity_id
			return true unless self.acts_as_ordered_has_exclusivity_id?
			raise ArgumentError.new( "You cannot swap the orders of two records from different exclusivity groups (#{acts_as_ordered_exclusivity_attribute_name} didn't match between items to swap)" ) unless x.send( self.acts_as_ordered_exclusivity_attribute_name ).eql?( y.send( self.acts_as_ordered_exclusivity_attribute_name ) )
		end

#	Order hash
#
#	Gets the order options hash for ActiveRecord insertion. You can say how you'd like to sort these
#
# DEPRECATED: use order_sort_order instead
#
#	Arguments:
#
#		order: (String) only values 'ASC' or 'DESC' are recognized (case matters)
		def order_options( order = 'ASC' )
			case order
				when 'ASC'
					{ :order => order_sort_order.collect{|column_name,direction| "#{column_name} #{direction.to_s}" }.join(', ') }
				when 'DESC'
					{ :order => order_sort_order.invert.collect{|column_name,direction| "#{column_name} #{direction.to_s}" }.join(', ') }
				else
					raise ArgumentError.new( "Only 'ASC' or 'DESC' is recognized. Got '#{order}'" )
			end
		end

# Creates the order specification in a CW::SortOrder structure
#
# Allows one to obtain the sorting instructions for this model
#
#	Returns:
#
#		(CW::SortOrder): The ascending sort order for this model. If you need it flipped, call invert on it
		def order_sort_order
			CW::SortOrder.asc( self.table_name + '.' + self.acts_as_ordered_order_attribute_name.to_s )
		end

# Exclusivity Conditions
#
# Gets the conditions for including ONLY records from this exclusivity group
#
#	Arguments:
#
#		exclusivity_id: (Varies) the exact exclusivity value to filter by
#
#	Returns:
#
#		(CW::Condition): conditions preloaded to include only the provided exclusivity_id
		def acts_as_ordered_exclusivity_conditions( exclusivity_id )
			ecn = self.table_name + '.' + self.acts_as_ordered_exclusivity_attribute_name.to_s
			CW::Condition.new( ["( #{ecn} = ? )",exclusivity_id] )
		end

# Find in order
#
#	Exactly like Model.find(:all), except all records are sorted in ascending order
#
# Arguments:
#
#		options: (Hash) of options you'd normally pass after :all in your find call
#
#	Raises:
#
#		(ArgumentError) if you try to call this function on a model that contains an exclusivity column. It doesn't make sense to do this as the ordering is meaningless across exclusivities
#
#	Returns:
#
#		(Array<ActiveRecord::Base>) models in order
		def find_in_order( options = {}, dir = 'ASC' )
			raise ArgumentError.new( "This has exclusivity, but you called a function that does not take into consideration exclusivity" ) if acts_as_ordered_has_exclusivity_id?
			options.merge!( order_options( dir ) )
			self.find( :all, options )
		end

# Find in order for exclusivity
#
#	Exactly like Model.find(:all), except all records are sorted in ascending order, and only those records that are contained in the exclusivity group provided are included
#
# Arguments:
#
#		exclusivity_d: (Varies) exact value of the exclusivity group you want to include. Only records with matching exclusivity_id will be included in the return value
#		options: (Hash) of options you'd normally pass after :all in your find call
#
#	Returns:
#
#		(Array<ActiveRecord::Base>) models in order
		def find_in_order_for_exclusivity( exclusivity_id, options = {}, dir = 'ASC' )
			options.merge!( order_options( dir ) )
			options[:conditions] = CW::Condition.and(options[:conditions],["#{self.table_name}.#{self.acts_as_ordered_exclusivity_attribute_name} = ?",exclusivity_id])
			
			self.find( :all, options )
		end
	end # ClassMethods
end # Model


# The Migration
#
# This allows you to programmatically create columns for your classes that require ordering. You can do so on table creation or add them after the fact. Note, if you rollback, you'll lose your ordering information that you've obtained so far.
#
# Examples:
# class CreateCandies < ActiveRecord::Migration
#         include CW::ActsAs::Ordered::Migration
#   def self.up
#     create_table :candies do |t| # you create this table
#       t.column :name, :string
#       t.timestamps
#     end
#
#			# This is where ActsAs::Ordered makes itself
#			# adds the hint and expiration fields to the stub class
# 		add_order_with_exclusivity( 'Candy', :acts_as_ordered_order, :user_id )
#   end
# 
#   def self.down
# 		remove_order_with_exclusivity( 'Candy', :acts_as_ordered_order, :user_id )
# 		# OR, just drop the whole table if you created it in this migration
#     drop_table :candies
#   end
# end
module Migration
	def self.included(base)
		base.extend(ClassMethods)
	end
	module ClassMethods
		def add_order( klass_name, order_column_name = :acts_as_ordered_order )
			add_ordered_field( klass_name, order_column_name )
			add_ordered_index( klass_name, order_column_name )
			klass_name.constantize.reset_column_information
			klass_name.constantize.acts_as_ordered_repair_holes
		end

		def add_order_with_exclusivity( klass_name, order_column_name = :acts_as_ordered_order, exclusivity_column_name = :acts_as_ordered_exclusivity_id, exclusivity_column_type = :integer, exclusivity_column_default = 0 )
			add_ordered_field( klass_name, order_column_name )
			add_exclusivity_field( klass_name, exclusivity_column_name, exclusivity_column_type, exclusivity_column_default )
			add_ordered_index( klass_name, [order_column_name,exclusivity_column_name] )
			klass_name.constantize.reset_column_information
			klass_name.constantize.acts_as_ordered_repair_holes
		end

		def add_ordered_field( klass_name, name )
			add_column klass_name.constantize.table_name, name, :integer # this MUST be an integer
		end

		def add_exclusivity_field( klass_name, name, type, default )
			add_column klass_name.constantize.table_name, name, type, :default => default, :null => false
		end

		def remove_order( klass_name, name = :acts_as_ordered_order )
			remove_ordered_index( klass_name, name )
			remove_column klass_name, name
		end

		def remove_order_with_exclusivity( klass_name, order_column_name = :acts_as_ordered_order, exclusivity_column_name = :acts_as_ordered_exclusivity_id )
			remove_ordered_index( klass_name, [order_column_name,exclusivity_column_name] )
			remove_ordered_field klass_name, order_column_name
			remove_exclusivity_field klass_name, exclusivity_column_name
		end

		def remove_ordered_field( klass_name, name = :acts_as_ordered_order )
			remove_column klass_name.constantize.table_name, name
		end

		def remove_exclusivity_field( klass_name, name = :acts_as_ordered_exclusivity_id )
			remove_column klass_name.constantize.table_name, name
		end

		def add_ordered_index( klass_name, columns = [:acts_as_ordered_order] )
			add_index klass_name.constantize.table_name, columns, :unique => true
		end

		def remove_ordered_index( klass_name, columns = [:acts_as_ordered_order] )
			remove_index klass_name.constantize.table_name, columns
		end
	end#ClassMethods
end#Migration

end#Ordered
end#ActsAs
end#CW
